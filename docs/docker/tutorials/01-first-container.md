---
title: "01. Первый контейнер"
type: tutorial
tags: [docker, tutorial, run, ports, detached, volumes, basics]
sources:
  docs: "https://docs.docker.com/get-started/"
related:
  - "[[docker/explanation/architecture]]"
  - "[[docker/how-to/install]]"
  - "[[docker/reference/cheatsheet]]"
prev: null
next: "[[docker/tutorials/02-building-images]]"
---

# Запуск первого контейнера

> **Цель:** Запустить первый контейнер, понять жизненный цикл (run → stop → rm),
> научиться читать логи и подключаться внутрь.

В этом уроке мы запустим веб-сервер Nginx, научимся управлять его жизненным циклом и поймем разницу между "Foreground" и "Background" режимами.

## Задача
Запустить Nginx, отдать статический HTML-файл с вашего компьютера и удалить контейнер после использования.

## Шаг 1: Запуск "здесь и сейчас" (Foreground)

Выполните команду:
```bash
docker run --rm -p 8080:80 nginx
```

**Что произошло?**
1.  `docker client` постучался к демону.
2.  Демон проверил, есть ли образ `nginx:latest` локально. Если нет — скачал (Pull) с Docker Hub.
3.  `-p 8080:80`: Порт 8080 на вашем хосте перенаправлен на порт 80 внутри контейнера.
4.  `--rm`: Контейнер удалится автоматически, когда он остановится. (Очень полезно для тестов, чтобы не мусорить).
5.  Вы видите логи Nginx прямо в консоли. Консоль "захвачена".

Откройте браузер: `http://localhost:8080`. Вы увидите "Welcome to nginx!".

Нажмите `Ctrl+C` в консоли. Контейнер остановился и удалился. Проверьте: `docker ps -a` (список должен быть чист).

## Шаг 2: Фоновый режим (Detached)

В продакшене сервисы работают в фоне.

```bash
docker run -d --name my-web -p 8080:80 nginx
```
*   `-d`: Detached mode. Контейнер запустился и отдал вам управление консолью.
*   `--name my-web`: Мы дали ему постоянное имя, чтобы не обращаться по случайному ID.

Проверьте статус:
```bash
docker ps
```

## Шаг 3: Просмотр логов

Так как контейнер в фоне, мы не видим, что там происходит.

```bash
docker logs my-web
```
*Видите логи доступа? (GET / HTTP/1.1)*

Чтобы следить в реальном времени (как `tail -f`):
```bash
docker logs -f my-web
```
*(Нажмите `Ctrl+C`, чтобы выйти из режима просмотра. Контейнер при этом продолжит работать!)*

## Шаг 4: Подмена контента (Bind Mount)

Дефолтная страница Nginx скучна. Давайте "прокинем" свой файл внутрь.

1.  Создайте файл `index.html` в текущей папке:
    ```html
    <h1>Hello from Docker!</h1>
    ```

2.  Удалите старый контейнер (он занимает порт 8080):
    ```bash
    docker rm -f my-web
    ```

3.  Запустите новый с монтированием тома:
    ```bash
    docker run -d \
      --name my-site \
      -p 8080:80 \
      -v $(pwd)/index.html:/usr/share/nginx/html/index.html:ro \
      nginx
    ```
    *   `-v $(pwd)/...`: Берем файл из текущей директории на хосте и кладем его по пути `/usr/share/...` в контейнере.
    *   `:ro`: Read-Only. Nginx не сможет изменить этот файл (безопасность).

Обновите `http://localhost:8080`. Вы увидите свой заголовок.

## Шаг 5: Уборка

Так как мы не использовали `--rm` во 2-м и 4-м шаге, контейнер остался висеть.

```bash
# Остановить и удалить
docker rm -f my-site

# Убедиться, что чисто
docker ps -a
```

## Итоги
1.  Использование `--rm` для временных задач.
2.  `-d` для фоновых сервисов.
3.  `-p` для публикации портов.
4.  `-v` для проброса файлов (Bind Mount).

## Типичные ошибки

| Ошибка | Симптом | Решение |
|--------|---------|---------|
| `docker run` без `-d` | Терминал заблокирован, нет prompt | Ctrl+C для остановки, далее использовать `-d` (detached) |
| Забыли `-p` при запуске | `curl localhost:80` → connection refused | `docker run -d -p 80:80 nginx` — порт нужно пробросить явно |
| `docker rm` работающего контейнера | `Error: cannot remove running container` | Сначала `docker stop`, потом `docker rm`. Или `docker rm -f` |
| Контейнер исчез из `docker ps` | «Куда делся мой контейнер?» | `docker ps -a` показывает остановленные. Контейнер завершился |