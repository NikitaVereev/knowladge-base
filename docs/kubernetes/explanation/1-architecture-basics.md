---
title: 1 Основы архитектуры Kubernetes
type: explanation
tags: [kubernetes, architecture, control-plane, worker-node, components]
---

Kubernetes — это не единый монолитный процесс, а распределенная система, состоящая из множества компонентов, работающих согласованно. Глобально кластер делится на две части:
1.  **Control Plane (Управляющий слой)** — "мозг" кластера, который принимает решения.
2.  **Worker Nodes (Рабочие узлы)** — "мышцы", где запускаются ваши приложения.

---

## Control Plane (Управляющий слой)

Эти компоненты управляют состоянием кластера. В production-среде они обычно дублируются на нескольких серверах для отказоустойчивости.

### 1. API Server (`kube-apiserver`)
Центральная точка входа. Это единственный компонент, с которым вы взаимодействуете напрямую (через `kubectl`).
*   **Функция:** Принимает REST-запросы, проверяет права доступа (Authentication/Authorization) и валидирует данные.
*   **Особенность:** Только API Server имеет право писать в базу данных кластера (Etcd). Все остальные компоненты общаются только через него.

### 2. Etcd
Распределенное хранилище данных типа "ключ-значение".
*   **Функция:** Хранит **все** состояние кластера: какие поды запущены, конфиги, секреты. Это "source of truth".
*   **Важно:** Если вы потеряете данные Etcd, вы потеряете кластер. Целостность кластера зависит от сохранности данных в Etcd.

### 3. Scheduler (`kube-scheduler`)
Планировщик, который решает, *где* запустить новый под.
*   **Функция:** Следит за появлением новых подов, у которых не назначен узел (`nodeName: ""`), и выбирает для них подходящий Worker Node.
*   **Логика:** Учитывает требования к ресурсам (CPU/RAM), правила Affinity (предпочтения) и Taints (ограничения).

### 4. Controller Manager (`kube-controller-manager`)
Набор фоновых процессов (контроллеров), которые следят за состоянием ресурсов.
*   **Функция:** Приводит *текущее* состояние к *желаемому*.
*   **Пример:** Если `ReplicaSet` должен держать 3 реплики, а одна упала — контроллер увидит расхождение и отправит запрос в API Server на создание новой.

---

## Worker Nodes (Рабочие узлы)

Машины (физические или виртуальные), на которых исполняются ваши приложения.

### 1. Kubelet
Главный агент, работающий на каждом узле.
*   **Функция:** Получает от API Server инструкции "Запусти вот этот список контейнеров" и следит за их здоровьем (Liveness/Readiness probes).
*   **Взаимодействие:** Напрямую управляет Container Runtime (Docker/containerd).

### 2. Kube-proxy
Сетевой прокси.
*   **Функция:** Реализует концепцию `Service` внутри узла. Управляет сетевыми правилами (обычно через `iptables` или `IPVS`), чтобы трафик попадал к нужному поду, даже если его IP-адрес изменился.

### 3. Container Runtime
Среда выполнения контейнеров.
*   **Функция:** Непосредственный запуск и остановка контейнеров.
*   **Примеры:** containerd (стандарт де-факто), CRI-O, Docker Engine (устаревает в качестве прямого рантайма).

---

## Как это работает вместе (Flow)

Когда вы выполняете команду `kubectl run nginx --image=nginx`:

1.  **kubectl** отправляет HTTP POST запрос к **API Server**.
2.  **API Server** проверяет права, сохраняет запись в **Etcd** и отвечает "OK".
3.  **Scheduler** (через watch-запрос) видит новый "бездомный" под и назначает ему узел (например, `node-1`), обновляя запись через API Server.
4.  **Kubelet** на узле `node-1` (через watch-запрос) видит, что ему назначен новый под.
5.  **Kubelet** дает команду **Container Runtime** скачать образ и запустить контейнер.
6.  **Kubelet** постоянно рапортует статус обратно в **API Server**.

### Визуальная схема
```text
User (kubectl) -> API Server -> Etcd
                      ^
                      |
        +-------------+-------------+
        |             |             |
    Scheduler   Controller Mgr    Kubelet (Node)
                                    |
                             Container Runtime
```
