---
title: 3 Анатомия образа - Слои и UnionFS
description: Как устроены Docker-образы? Union File System, стратегия Copy-on-Write (CoW) и разница между Image Layer и Container Layer.
---

## Образ как слоеный пирог

Docker-образ — это не один большой файл (как ISO или OVA), а упорядоченный набор **слоев** (Layers), доступных только для чтений (Read-Only).

Каждая инструкция в `Dockerfile` (такая как `RUN`, `COPY`, `ADD`) создает новый слой.
Физически слой — это архив (`tar.gz`) с изменениями файловой системы (diff) относительно предыдущего слоя.

Пример:
1.  `FROM ubuntu:22.04` — Базовый слой (файлы ОС).
2.  `RUN apt-get install python3` — Слой, содержащий *только* файлы Python (добавленные поверх Ubuntu).
3.  `COPY . /app` — Слой, содержащий *только* ваш исходный код.

## Union File System (UnionFS)

Чтобы контейнер видел эти разрозненные архивы как единую файловую систему, используется механизм **Union Mount** (обычно драйвер `overlay2` в Linux).

UnionFS "накладывает" слои друг на друга.
*   Если файл `/etc/my.conf` есть в нижнем слое, и в верхнем слое — контейнер увидит версию из **верхнего** слоя.
*   Если файл удален в верхнем слое — он помечается как "скрытый" (whiteout), но физически остается в нижних слоях (поэтому удаление файлов в новом слое **не уменьшает** размер образа!).

## Container Layer (RW) и Copy-on-Write

Когда вы запускаете контейнер (`docker run`), Docker берет стопку Read-Only слоев образа и добавляет сверху **один тонкий слой для записи** (Read-Write Container Layer).

### Стратегия Copy-on-Write (CoW)
Все изменения, которые делает запущенное приложение, происходят *только* в этом верхнем слое.

1.  **Чтение**: Если приложение хочет прочитать файл, который лежит в нижнем (Read-Only) слое, оно читает его напрямую. Быстро, без оверхеда.
2.  **Запись**: Если приложение хочет *изменить* файл из нижнего слоя:
    *   Docker сначала **копирует** этот файл целиком в верхний RW-слой.
    *   Приложение меняет копию.
    *   Оригинал в нижнем слое остается нетронутым.

**Эффект масштаба:**
Если вы запустите 100 контейнеров `nginx` (размером 100 МБ), они **не займут** `100 * 100 = 10 ГБ`.
Они займут `100 МБ` (один общий Read-Only образ) + `X КБ` (уникальные данные в RW-слое каждого контейнера). Это колоссальная экономия места.

## Кеширование сборки

Понимание слоев — ключ к быстрой сборке.
Docker кеширует каждый слой. Если вы меняете одну строку в коде приложения (последний слой), Docker **не пересобирает** предыдущие слои (установку зависимостей `npm install`), если `package.json` не менялся.

Поэтому в `Dockerfile` всегда сначала копируют файлы зависимостей, ставят их, и только потом копируют код приложения:

```dockerfile
# Слой 1: Кешируется, если package.json не менялся
COPY package.json .
RUN npm install

# Слой 2: Пересобирается при любом изменении кода
COPY . .
```

## Dangling Images (<none>)

Иногда вы видите образы с именем `<none>:<none>`. Это **Dangling** (повисшие) образы.
Они появляются, когда вы пересобираете образ с тем же тегом (`my-app:latest`).
*   Старый образ теряет имя (тег переходит к новому).
*   Он остается на диске, занимая место.
*   Это не ошибка, это мусор. Удаляются командой `docker image prune`.

Не путать с промежуточными слоями (Intermediate Layers), которые тоже показываются как `<none>`, но являются родителями для других образов и удалять их нельзя.
