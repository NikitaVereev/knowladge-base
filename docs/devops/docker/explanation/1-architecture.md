---
title: "1 Архитектура Docker"
description: "Как устроен Docker изнутри: Docker Engine, containerd/runc (OCI), namespaces, cgroups v2, слои образов, сеть/тома и отличие от виртуальных машин."
---

Docker — это платформа для сборки, доставки и запуска приложений в изолированных контейнерах. На Linux контейнеры используют общее ядро хоста, изолируя процессы и ресурсы средствами ядра (namespaces/cgroups), а не эмулируя «железо», как виртуальные машины.

Важно: Docker — это не только «контейнеры», а стек компонентов (CLI → API → демоны → runtime), который стандартизирован вокруг OCI (Open Container Initiative).

## Контейнеры vs Виртуальные машины

Главное отличие — **уровень абстракции** и то, что именно изолируется.

| Характеристика | Контейнер (Docker) | Виртуальная машина (VM) |
|---|---|---|
| **Изоляция** | На уровне процессов (user space) | На уровне виртуального «железа» (hypervisor) |
| **ОС** | (Linux) использует ядро хоста | Загружает свою гостевую ОС (guest OS + kernel) |
| **Размер** | Обычно МБ (app + зависимости) | Обычно ГБ (ОС + app) |
| **Старт** | Секунды/доли секунды (как запуск процесса) | Секунды–минуты (загрузка ОС) |
| **Производительность** | Близко к нативной | Есть накладные расходы hypervisor/эмуляции |

Практическая оговорка: на macOS и Windows контейнеры Linux обычно запускаются внутри легковесной Linux-VM (например, в Docker Desktop), поэтому «делят ядро» — с ядром этой VM, а не с ядром хоста.

## Компоненты Docker Engine (современный стек)

Docker в продакшене — это цепочка из нескольких процессов и стандартов:

- **Docker Client (`docker`)**: CLI, которая отправляет запросы в API Docker Engine (обычно через Unix socket).
- **Docker Engine API**: интерфейс управления контейнерами/образами/сетями/томами.
- **Docker Daemon (`dockerd`)**: главный демон, который реализует API, управляет жизненным циклом объектов и делегирует запуск контейнеров нижележащему runtime.
- **containerd**: менеджер контейнеров более низкого уровня (pull/push образов, хранение снапшотов, запуск задач).
- **OCI runtime (`runc`)**: компонент, который непосредственно создает контейнер как набор Linux-примитивов (namespaces, cgroups, mount и т.д.) на основе OCI-spec.
- **shim-процессы**: вспомогательные процессы, которые позволяют контейнеру жить независимо от клиентской сессии и упрощают управление stdout/stderr и сигналами.

Ментальная модель: Docker «упаковывает» приложение в image, «распаковывает» его в filesystem-снапшот и запускает как процесс с ограничениями и изоляцией.

## Изоляция и ограничения (ядро Linux)

Docker не «изобретает» изоляцию, а комбинирует возможности ядра Linux и политики безопасности.

### Namespaces: что процесс видит
Namespaces задают контейнеру отдельные «пространства» имен:

- **PID namespace**: внутри контейнера свой набор PID; процесс может быть PID 1 внутри контейнера.
- **Network namespace**: отдельные интерфейсы, IP, маршруты, iptables/nft правила (в пределах namespace).
- **Mount namespace**: свое дерево монтирования и корневая FS.
- **UTS namespace**: свой hostname.
- **IPC namespace**: изоляция shared memory/семафоров.
- **User namespace (опционально)**: маппинг uid/gid (важно для rootless и снижения привилегий).

### Cgroups: что процесс может использовать
cgroups (в т.ч. cgroups v2) ограничивают и учитывают ресурсы:

- CPU (shares/quotas).
- Memory (лимиты, OOM поведение).
- Block I/O и device access (в зависимости от настроек).

### Дополнительные механизмы безопасности
Помимо namespaces/cgroups, обычно важны:

- **Linux capabilities**: контейнеру можно убрать привилегии «root» по принципу least privilege.
- **seccomp**: фильтрация системных вызовов (уменьшает поверхность атаки).
- **AppArmor/SELinux**: обязательный контроль доступа (MAC), особенно актуально в enterprise-средах.
- **Rootless containers**: режим, где Docker/контейнеры работают без root на хосте.

## Файловая система: образы, слои и Copy-on-Write

Docker-образ (image) — это набор неизменяемых слоев (read-only layers). Контейнер при запуске получает тонкий **rw-слой** поверх image, и изменения пишутся туда.

- **Copy-on-Write (CoW)**: если контейнер изменяет файл из нижнего слоя, драйвер хранения создает копию в rw-слое контейнера.
- **Storage drivers**: на Linux чаще всего используется `overlay2` (как наиболее практичный и производительный дефолт в большинстве дистрибутивов).
- **Volumes vs rw-слой**: для данных (БД, кэши, артефакты) лучше использовать volumes/маунты, а не полагаться на rw-слой контейнера, потому что rw-слой предназначен для эфемерных изменений и хуже масштабируется по управлению жизненным циклом данных.

## Сеть в Docker (в двух словах)

Docker создает виртуальные сети и подключает контейнеры через сетевые драйверы.

- **bridge**: дефолтный режим на одном хосте (NAT, проброс портов).
- **host**: контейнер разделяет network namespace с хостом (меньше изоляции, иногда меньше оверхеда).
- **none**: сеть выключена.
- **overlay**: для многонодовых кластеров (часто в связке с orchestration).

Порт-маппинг (`-p 8080:80`) обычно означает: входящий трафик на порт хоста перенаправляется в контейнер через правила NAT.

## Практические ориентиры (best practices)

- Используйте **rootless** там, где это возможно, или минимизируйте привилегии: `--cap-drop=ALL` + точечный `--cap-add=...` при необходимости.
- Храните состояние в **volumes** (или внешних сториджах), а контейнеры делайте максимально stateless.
- Старайтесь собирать образы через **multi-stage build** и минимальные базовые образы, чтобы снижать размер и поверхность атаки.
- В продакшене разделяйте «сборку» и «запуск»: сборка в CI, запуск на хостах/в кластере из registry.

## Связанные материалы

- [[1-quickstart|Быстрый старт: запуск первого контейнера]]
- [[1-install-docker|Установка Docker]]

