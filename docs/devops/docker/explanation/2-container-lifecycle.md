---
title: 2 Жизненный цикл контейнера
description: Понимание контейнера как процесса Linux. PID 1, обработка сигналов (SIGTERM/SIGKILL), Exit Codes и разбор состояний (Created, Running, Exited).
---

## Контейнер — это просто процесс

Самое важное техническое понимание Docker: **Контейнер — это не "мини-виртуалка", это изолированный процесс**.
В отличие от виртуальной машины, которая загружает полноценное ядро ОС, контейнер использует ядро хостовой системы.

Если вы запустите контейнер с базой данных Postgres и выполните `ps aux` на хост-машине (сервере), вы увидите процесс `postgres`. Просто он "огорожен" от остальных процессов с помощью Namespaces (видимость) и Cgroups (ресурсы).


## Главный процесс (PID 1)

Внутри Linux Namespaces (в "мире" контейнера) процессы нумеруются с 1.
Первый запущенный процесс получает **PID 1**. Это критически важно, потому что в Linux процесс с PID 1 (обычно это `systemd` или `init`) имеет особые обязанности:
1.  Принимать системные сигналы (остановка, перезагрузка) и передавать их дочерним процессам.
2.  "Убирать" за зомби-процессами (reap zombies).

### Проблема Shell-формы
Если в Dockerfile вы напишете:
```dockerfile
CMD ./start.sh
```
Docker запустит это как `/bin/sh -c ./start.sh`.
*   **PID 1**: `/bin/sh`
*   **PID 2**: `./start.sh` (ваше приложение)

Shell (`sh`) **не передает** сигналы дочерним процессам. Когда вы делаете `docker stop`, сигнал летит в `sh`, тот его игнорирует, и через 10 секунд Docker убивает всех "топором" (SIGKILL).

**Решение**: Использовать `exec` в скриптах или JSON-формат в Dockerfile (`CMD ["./start.sh"]`), чтобы приложение само стало PID 1.

## Graceful Shutdown (Цепочка остановки)

Команда `docker stop my-container` запускает строгий алгоритм:

1.  **Отправка SIGTERM (15)**: Docker посылает сигнал процессу PID 1.
    *   *Ожидание*: Приложение должно поймать сигнал, перестать принимать новые запросы, дописать транзакции в БД, закрыть сокеты и выйти.
2.  **Таймаут (Stop Grace Period)**: По умолчанию 10 секунд. Можно настроить (`--stop-timeout`).
3.  **Отправка SIGKILL (9)**: Если процесс все еще жив, ядро принудительно уничтожает его. Данные в памяти теряются, файлы могут побиться.

## Состояния контейнера (Lifecycle States)

Контейнер не может быть "просто включен". У него есть конечный автомат состояний:

1.  **Created**: Контейнер создан (слои подготовлены, конфиг записан), но процесс еще не запущен. (Команда `docker create`).
2.  **Running**: Процесс PID 1 запущен и работает.
3.  **Paused**: Процесс заморожен (через cgroups freeze). Он в памяти, но не получает процессорного времени.
4.  **Exited**: Процесс PID 1 завершился (сам или был убит). Контейнер остановлен, но файловая система и логи сохранены на диске. (Можно сделать `docker start` снова).
5.  **Dead / Removing**: Переходные состояния при удалении или фатальных ошибках демона.

## Exit Codes (Коды выхода)

Когда контейнер падает (Status: Exited), первое, что нужно смотреть — код выхода. Это ответ на вопрос "Почему?".

| Код | Название | Причина и Диагностика |
| :--- | :--- | :--- |
| **0** | Success | Штатное завершение. Процесс решил, что работа выполнена (например, скрипт бэкапа закончил работу). |
| **1** | Application Error | Внутренняя ошибка приложения. Смотрите логи (`docker logs`). Исключение, stacktrace. |
| **137** | SIGKILL (128+9) | **OOM Killer**. Контейнер съел больше памяти, чем разрешено лимитом, и был убит ядром. Либо вы сделали `docker kill`. |
| **139** | SIGSEGV (128+11) | **Segfault**. Ошибка сегментации памяти. Обычно проблема в бинарных библиотеках (C/C++), несовместимости версий библиотек. |
| **127** | Command Not Found | Docker не нашел исполняемый файл, указанный в CMD/ENTRYPOINT. Проверьте пути и наличие файла в образе. |

Понимание этих кодов критично для написания `restart_policy` (например, `on-failure` перезапустит при коде 1, но не при коде 0) и настраивать Kubernetes Liveness Probes.
