---
title: 1 Основы архитектуры Docker
type: explanation
tags: [docker, architecture, daemon, containerd, runc, namespaces, cgroups]
---

# Архитектура Docker

Docker — это не монолитное приложение, а платформа, работающая по клиент-серверной архитектуре. Она абстрагирует управление примитивами ядра Linux (namespaces, cgroups) для запуска процессов в изолированных окружениях.

Понимание архитектуры необходимо для отладки проблем с правами доступа, сетью и производительностью, а также для понимания отличий Docker от виртуальных машин.

## Client-Server Модель

Работа Docker строится на взаимодействии трех компонентов:

1.  **Docker Client (`docker`)**: Утилита командной строки (CLI), с которой взаимодействует пользователь. Клиент не запускает контейнеры самостоятельно; он конвертирует команды (например, `docker run`) в REST API запросы.
2.  **Docker Host (Daemon `dockerd`)**: Фоновй процесс, работающий на хост-системе. Он слушает запросы от клиента, управляет объектами (образы, контейнеры, сети, тома) и делегирует задачи низкоуровневым рантаймам.
3.  **Registry**: Хранилище образов (Docker Hub, GHCR, Private Registry).

### Docker Socket (`/var/run/docker.sock`)
Взаимодействие между Клиентом и Демоном происходит через UNIX-сокет (по умолчанию) или TCP-сокет.
*   **UNIX Socket**: Файл, принадлежащий `root` (или группе `docker`). Предоставление доступа к этому файлу эквивалентно выдаче прав `root` на хосте.
*   **TCP Socket**: Используется для удаленного управления, требует настройки TLS для безопасности.

> **Важно:** В среде macOS и Windows Docker Desktop запускает демон внутри скрытой виртуальной машины Linux. Клиент на хосте (macOS) общается с демоном внутри VM через специальный прокси-сокет.

## Стек выполнения (The OCI Stack)

Начиная с версии 1.11, Docker перешел на модульную архитектуру, основанную на стандартах OCI (Open Container Initiative). Демон `dockerd` больше не создает контейнеры напрямую.

### 1. containerd (High-Level Runtime)
Индустриальный стандарт управления жизненным циклом контейнеров.
*   **Роль:** Управляет образами (pull/push), хранилищем и сетевыми интерфейсами.
*   **Задача:** Получить команду от `dockerd` и подготовить всё необходимое (слои файловой системы, спецификацию OCI Bundle) для запуска.
*   `containerd` используется и в Kubernetes (через CRI), что делает Docker и K8s совместимыми на уровне образов.

### 2. runc (Low-Level Runtime)
Референсная реализация спецификации OCI Runtime.
*   **Роль:** Непосредственное взаимодействие с ядром Linux.
*   **Задача:** Создать системный процесс, применив к нему пространства имен (namespaces) и лимиты (cgroups).
*   После запуска контейнера процесс `runc` завершается, передавая управление процессу приложения. Это позволяет обновлять Docker/containerd без остановки запущенных контейнеров.

### 3. containerd-shim
Прослойка между `containerd` и процессом контейнера.
*   Позволяет `runc` завершиться после запуска контейнера (daemonless containers).
*   Держит открытыми потоки ввода-вывода (STDIN/STDOUT/STDERR).
*   Отслеживает код выхода (exit code) контейнера и сообщает его демону.

## Примитивы ядра Linux

Docker не использует виртуализацию железа (как VMware или KVM). Изоляция достигается средствами ядра Linux.

### Namespaces (Пространства имен)
Обеспечивают изоляцию **видимости**. Процесс в контейнере "думает", что он единственный (или главный) в системе.
*   `PID`: Изоляция процессов. PID 1 в контейнере — это не PID 1 на хосте.
*   `NET`: Свой сетевой стек (IP, порты, таблицы маршрутизации).
*   `MNT`: Изолированная файловая система (mount points).
*   `IPC`: Изоляция межпроцессного взаимодействия (Shared Memory).
*   `UTS`: Свое имя хоста (hostname).
*   `USER`: Маппинг UID/GID (позволяет быть root внутри контейнера, но обычным пользователем снаружи).

### Cgroups (Control Groups)
Обеспечивают изоляцию **ресурсов**.
*   Ограничивают потребление CPU, RAM, Disk I/O.
*   Позволяют демону убить контейнер при превышении лимита памяти (OOM Killer).

### Capabilities
Docker по умолчанию запускает контейнеры с урезанным набором привилегий root. Механизм Linux Capabilities позволяет дробить права суперпользователя.
*   Например, контейнеру разрешено открывать порты (`NET_BIND_SERVICE`), но запрещено менять системное время (`SYS_TIME`) или загружать модули ядра.

## Итоговая схема запуска

1.  **CLI**: `docker run nginx` → API Request.
2.  **dockerd**: Проверяет наличие образа, создает конфигурацию. Вызывает `containerd`.
3.  **containerd**: Распаковывает образ в слой CoW. Передает OCI bundle в `runc`.
4.  **runc**: Просит ядро создать namespaces/cgroups. Запускает процесс `nginx`. Завершается.
5.  **shim**: Остается привязанным к `nginx` для логгирования и управления.
