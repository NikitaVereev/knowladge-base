---
title: 7 Паттерн Композиции - Docker Compose
description: Переход от императивного запуска к декларативному. Как решать проблему зависимостей (Healthchecks) и управлять ресурсами (Profiles).
---

## От одиночных контейнеров к Системам

В реальной разработке приложение никогда не работает в изоляции. Ему нужны база данных, кеш, очередь сообщений.
Запускать их руками через `docker run` - это путь ошибок. Вы абудете создать сеть, забудете прокинуть переменную окружения или ошибетесь в порядке запуска.

**Docker Compose** - это инструмент для описания и запуска многоконтейнерных приложений. Он реализует принцип **Infrastructure as Code (IaC)** на локальном уровне.

## Декларативность и Идемпотентность

Файл `compose.yaml` (ранее `docker-compose.yml`) описывает **Желаемое Состояние** системы.

Когда вы пишете команду `docker compose up`, Docker сравнивает:
1. То, что описано в YAML.
2. То, что сейчас запущено в Docker Engine.

Если контейнер уже запущен и его конфиг не менялся - Compose **ничего не сделает**. Это свойство называется **идемпотентностью**. Это отличает его от bash-скрипта, который каждый рз будет пытаться создать контейнер заново и падать с ошибкой "Name already in use"

## Изоляция Проектов (Project Name)

Compose позволяет запускать несколько копий одного и того же окружения на одной машине (например, для разных веток git или для разных разработчиков на общем dev-сервере).

Это достигается за счет **Project Name**.
По умолчанию имя проекта = имя текущей дирректории.
* Все ресурсы (сети, тома, контейнеры) получают префикс: `folder_service_1`.
* Сети изолированы: `folder_default`.

Вы можете принудительно задать имя через `-p myproject`, чтобы запустить копию стека рядом с основной.

## Внешний нюанс (Race Condition)

Представьте, что Бэкенд зависит от Базы Данных. Вы говорите Docker'у: "Запусти сначала Базу, потом Бэкенд" (используя `depends_on`).

**Что происходит на самом деле:**
1. Docker запускает процесс Базы Данных.
2. Процесс появился (PID 1 жив) — Docker считает, что База запущена.
3. Docker тут же запускает Бэкенд.
4. **НО!** Базе данных нужно время (5-10 секунд), чтобы загрузить файлы с диска и открыть порт для соединений.
5. Бэкенд пытается подключиться, видит, что порт закрыт, и падает с ошибкой `Connection Refused`.

Это классическая ошибка новичка. `depends_on` по умолчанию ждет только *старта процесса*, а не *готовности сервиса*.

### Решение: Healthchecks 

Healthcheck — это способ спросить у контейнера: "Ты реально готов работать, или просто запустился?".

В `compose.yaml` вы учите Docker проверять здоровье сервиса:
```yaml
services:
  db:
    image: postgres
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres"] # Команда проверки
      interval: 5s  # Проверять каждые 5 секунд
      timeout: 5s   # Ждать ответа 5 секунд
      retries: 5    # После 5 неудач считать контейнер больным (unhealthy)
```

А в зависимом сервисе вы говорите: "Жди, пока БД не станет **healthy**":
```yaml
  backend:
    depends_on:
      db:
        condition: service_healthy # <--- Магия здесь
```
Теперь Docker будет ждать эти 10 секунд инициализации базы, и только потом запустит бэкенд. Приложение стартует без ошибок.

## Profiles (Профили запуска)

В больших проектах в `compose.yaml` может быть описано много сервисов:
*   Основные: Backend, Database, Frontend.
*   Вспомогательные: Prometheus (мониторинг), Jaeger (трейсинг), Adminer (GUI для базы), End-to-End тесты.

Если запускать `docker compose up`, поднимутся **все** 10-15 контейнеров. Это съест всю память ноутбука, хотя для разработки текущей фичи вам нужен только Бэкенд и База.

**Профили** позволяют пометить сервисы тегами:

```yaml
services:
  backend:
    # Без профиля — запускается всегда по умолчанию
  
  phpmyadmin:
    image: phpmyadmin
    profiles: ["tools"] # Запускать только явно
  
  cypress-tests:
    image: cypress
    profiles: ["test"]
```

Теперь у вас есть гибкость:
*   `docker compose up` — запустит только основное (Backend + DB).
*   `docker compose --profile tools up` — запустит основное + phpmyadmin.
*   `docker compose --profile test up` — запустит окружение для тестов.

Это позволяет держать всю инфраструктуру проекта в одном файле, но включать её части по мере необходимости.
