---
title: 5 Сетевая модель - DNS и изоляция
description: Как контейнеры общаются друг с другом? Service Discovery, встроенный DNS-сервер Docker и разница между User-defined Bridge и Default Bridge.
---

## Абстракция CNM (Container Network Model)

Docker использует сетевую модель, где каждый контейнер имеет свой собственный сетевой стек (свой IP, свои интерфейсы, свой localhost), изолированный от хоста.

Чтобы контейнеры могли общаться, их нужно подключить к одной **Сети (Network)**. Сеть — это программный коммутатор (Software Switch).

## Типы драйверов

### 1. Bridge (Мост) — Стандарт
Драйвер по умолчанию. Создает виртуальный мост (виртуальный свитч) на хосте (`docker0`).
*   Контейнеры в одной bridge-сети видят друг друга по IP.
*   Извне (с хоста или интернета) они **недоступны**, пока вы явно не опубликуете порты.

### 2. Host (Хост)
Убирает сетевую изоляцию. Контейнер использует сетевой интерфейс хоста напрямую.
*   *Эффект*: Если приложение слушает порт 80 внутри контейнера, оно сразу занимает порт 80 на хост-машине.
*   *Плюсы*: Максимальная производительность (нет NAT).
*   *Минусы*: Конфликты портов. Нельзя запустить два одинаковых контейнера. Работает только на Linux.

### 3. None
Полное отсутствие сети. Только loopback интерфейс (`127.0.0.1`). Для задач с высокой безопасностью.

## Магия DNS и Service Discovery

Самая мощная фича Docker Networking — **автоматический DNS**.

Когда вы создаете свою сеть (`docker network create my-app`) и запускаете в ней контейнеры:
1.  Docker запускает встроенный DNS-сервер (по адресу `127.0.0.11` внутри контейнера).
2.  Когда контейнер `frontend` пытается обратиться к `http://backend`, DNS Docker'а отвечает внутренним IP-адресом контейнера `backend`.

**Важное отличие Default Bridge vs User-defined Bridge:**
*   В дефолтной сети `bridge` (куда попадают контейнеры без указания сети) **DNS по именам НЕ работает**. Контейнеры могут общаться только по IP-адресам (которые меняются при перезапуске).
*   В пользовательских сетях (`docker network create ...`) **DNS работает автоматически**.

**Правило**: Всегда создавайте свои сети для проектов. Никогда не используйте дефолтный bridge для связки контейнеров.

## Публикация портов (Port Mapping)

Контейнеры закрыты от внешнего мира. Чтобы впустить трафик, используется флаг `-p HOST_PORT:CONTAINER_PORT`.

```bash
docker run -p 8080:80 nginx
```
*   **80** — порт, который слушает Nginx ВНУТРИ контейнера.
*   **8080** — порт, который открывается НА ХОСТЕ.

Docker добавляет правило **DNAT** (Destination NAT) в iptables хоста: "Всё, что пришло на порт 8080, пересылай на IP-адрес контейнера на порт 80".

## Сетевая изоляция (Security)

Docker позволяет сегментировать приложение.
Пример архитектуры:
1.  Сеть `frontend-net`: В ней живут Nginx и React-сервер. Открыта наружу (публикация портов).
2.  Сеть `backend-net`: В ней живут Go-сервис и Postgres. **Закрыта снаружи**.

Если поместить `backend` и `postgres` в отдельную сеть, к которой у `frontend` нет доступа, то даже в случае взлома фронтенда, хакер не получит прямого сетевого доступа к базе данных. Бэкенд служит шлюзом.
