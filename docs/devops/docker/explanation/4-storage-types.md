---
title: "4 Хранение данных"
description: "Где и как хранить файлы в Docker: Volumes, Bind Mounts и tmpfs, а также практические правила выбора."
---

По своей природе контейнеры — **эфемерны**: изменения в файловой системе контейнера живут только пока жив контейнер. 

Чтобы данные пережили пересоздание контейнера, их нужно хранить вне writable-layer контейнера — через **Volumes**, **Bind Mounts** или **tmpfs**. 

## 1. Volumes (Тома) — стандарт для данных

Volumes — это managed-хранилище, которое Docker создает и администрирует сам. 

- Когда использовать: базы данных (Postgres/MySQL), постоянные данные приложения, production-хранилище. 
- Плюсы: переносимость (не завязаны на путь хоста), проще мигрировать/бэкапить как отдельную сущность, меньше риск случайно “перетереть” файлы хоста. 
- Минусы: не так удобно открывать руками в файловом менеджере (обычно нужен docker/root-доступ и знание, где volume хранится). 

```yaml
# docker-compose.yml
services:
  db:
    image: postgres
    volumes:
      - pgdata:/var/lib/postgresql/data

volumes:
  pgdata:
```

## 2. Bind Mounts (Привязки)

Bind mount — это монтирование конкретного файла/директории хоста внутрь контейнера. 

- Когда использовать: локальная разработка (код/горячая перезагрузка), прокидывание конфигов (nginx.conf), интеграция с файлами на хосте. 
- Плюсы: прозрачно и удобно — редактируете на хосте, контейнер сразу видит изменения. 
- Минусы: завязка на пути/права конкретной ОС и окружения, легче случайно повредить данные хоста (контейнер пишет прямо в вашу ФС). 

```yaml
services:
  app:
    image: node:20
    volumes:
      - ./src:/app/src
      - ./nginx.conf:/etc/nginx/nginx.conf
```

## 3. tmpfs — временная ФС в памяти

`tmpfs` — это монтирование директории контейнера в оперативную память хоста (RAM), то есть данные **не пишутся на диск** и пропадают при остановке/удалении контейнера. 

- Когда использовать: временные файлы, кэш/буферы, чувствительные данные “на время выполнения” (которые не должны попадать на диск), каталоги вроде `/tmp`, `/run`. 
- Плюсы: быстрее диска в write-heavy сценариях, данные не остаются на диске после остановки. 
- Минусы: потребляет память; при перезапуске контейнера содержимое исчезает. 

Пример (CLI):

```bash
docker run --rm -it \
  --tmpfs /tmp:rw,noexec,nosuid,size=256m \
  alpine:latest sh
```

Пример (Compose):

```yaml
services:
  app:
    image: alpine:latest
    command: ["sh", "-lc", "echo hi > /tmp/x && ls -la /tmp"]
    tmpfs:
      - /tmp
```

## Сводная таблица выбора

| Задача | Что выбрать | Пример |
|---|---|---|
| Мне нужна БД Postgres (данные должны переживать пересоздание) | **Volume** | `-v pgdata:/var/lib/postgresql/data` |
| Я пишу код и хочу live reload | **Bind Mount** | `-v ./src:/app/src` |
| Мне нужно подложить один конфиг в контейнер | **Bind Mount** | `-v ./nginx.conf:/etc/nginx/nginx.conf:ro` |
| Мне нужен быстрый временный каталог, который не должен попасть на диск | **tmpfs** | `--tmpfs /tmp:size=256m` |

## Практические best practices

- Для production-данных почти всегда выбирайте **volumes**, а не bind mounts. 
- Для конфигов чаще используйте bind mount в режиме `:ro`, чтобы контейнер не мог перезаписать файл на хосте. 
- Для временных данных и кэшей в runtime используйте **tmpfs**, особенно если важно не оставлять следы на диске. 
