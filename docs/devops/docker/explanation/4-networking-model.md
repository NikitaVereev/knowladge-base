---
title: 4 Сетевая модель (CNM)
type: explanation
tags: [docker, networking, cnm, bridge, overlay, dns, service-discovery]
---

# Сетевая модель Docker (CNM)

Docker использует модель Container Network Model (CNM), которая стандартизирует сетевое взаимодействие для контейнеров. Она позволяет контейнерам общаться друг с другом и с внешним миром, абстрагируясь от физической инфраструктуры сети.

В основе CNM лежат три объекта:
1.  **Sandbox**: Изолированная сетевая среда контейнера (Network Namespace). Содержит интерфейсы, таблицу маршрутизации и DNS-настройки.
2.  **Endpoint**: Сетевой интерфейс (виртуальная сетевая карта), соединяющий Sandbox с сетью.
3.  **Network**: "Программный коммутатор" (Software Switch), через который пакеты передаются между эндпоинтами.

## Драйверы сетей

Docker поддерживает подключаемые драйверы. Выбор драйвера определяет топологию и поведение сети.

### 1. Bridge (Мост) — По умолчанию
Используется для связи контейнеров на **одном** хосте.
*   При установке Docker создает дефолтный мост `docker0`.
*   Контейнеры получают внутренний IP-адрес из подсети моста (например, `172.17.0.x`).
*   **Изоляция:** Контейнеры в одной bridge-сети видят друг друга по IP. Контейнеры в разных bridge-сетях изолированы.
*   **Доступ снаружи:** По умолчанию закрыт. Чтобы открыть сервис миру, используется Port Publishing (`-p 80:80`), который создает правило DNAT в iptables хоста.

> **Default vs User-defined Bridge:**
> *   В дефолтном мосту (`bridge`) контейнеры могут общаться **только по IP-адресам**.
> *   В пользовательских мостах (`docker network create my-net`) работает **автоматический DNS (Service Discovery)**, позволяющий обращаться к контейнерам по именам.

### 2. Host
Убирает сетевую изоляцию между контейнером и хостом.
*   Контейнер не получает свой IP, а использует IP хоста.
*   Порт 80 контейнера сразу открывается на порту 80 хоста (флаг `-p` игнорируется).
*   **Плюс:** Максимальная производительность (нет накладных расходов на NAT).
*   **Минус:** Возможны конфликты портов. Работает только на Linux (на Mac/Windows из-за VM-прослойки поведение отличается).

### 3. None
Полностью отключает сеть. В контейнере есть только loopback-интерфейс (`lo`). Используется для batch-задач, которым не нужен интернет.

### 4. Overlay
Позволяет связывать контейнеры, запущенные на **разных** хостах (в режиме Docker Swarm). Создает распределенную подсеть поверх физической сети узлов, инкапсулируя трафик (обычно VXLAN).

### 5. Macvlan
Позволяет присвоить контейнеру MAC-адрес, делая его полноценным устройством в физической сети (например, подключенным к офисному роутеру). Контейнер получает IP-адрес напрямую от DHCP-сервера вашей локальной сети, минуя NAT Docker-а.

## DNS и Service Discovery

Docker имеет встроенный DNS-сервер (Embedded DNS Server, `127.0.0.11` внутри контейнера).

1.  Когда контейнер `app` пытается обратиться к `db`:
2.  Запрос идет на `127.0.0.11`.
3.  Docker проверяет, находятся ли `app` и `db` в одной пользовательской сети (User-defined bridge).
4.  Если да — возвращает IP-адрес контейнера `db`.
5.  Если имя внешнее (google.com) — запрос пересылается на DNS-сервера хоста.

> **Важно:** DNS resolution по именам контейнеров **не работает** в дефолтной сети `bridge`. Это сделано для обратной совместимости. Поэтому в Docker Compose всегда создается отдельная сеть для проекта, где DNS работает "из коробки".

## Публикация портов (Ingress)

Когда вы делаете `docker run -p 8080:80`, происходит следующее:
1.  **docker-proxy**: (User-space) процесс слушает порт 8080 на хосте и пересылает трафик в контейнер.
2.  **iptables**: (Kernel-space) создается правило DNAT. Обычно трафик идет через iptables (быстрее), а `docker-proxy` остается как запасной вариант (fallback) или для localhost-трафика.

Это означает, что firewall хоста (например, UFW) может быть обойден правилами Docker, так как Docker вставляет свои правила в цепочку `PREROUTING` раньше обычных пользовательских правил.
