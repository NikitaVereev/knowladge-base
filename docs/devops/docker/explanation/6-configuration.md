---
title: 6 Конфигурация - ENV, Файлы и Секреты
description: Как настраивать приложение в Docker? Принципы 12-Factor App, иерархия Environment Variables, внедрение конфиг-файлов и работа с секретами.
---

## Принцип "Config in the Environment"

Согласно методологии **12-Factor App**, конфигурация, которая меняется между деплоями (Dev, Stage, Prod), должна храниться в **переменных окружения** (Environment Variables), а не в коде.

Docker образ должен быть **агностиком окружения**.
*   *Плохо*: Делать разные образы `myapp:dev` и `myapp:prod` с разными зашитыми конфигами.
*   *Хорошо*: Один образ `myapp:v1`, который при старте читает `DB_HOST` и ведет себя соответственно.

## Способы передачи переменных (ENV)

У Docker есть четкая иерархия приоритетов (от низшего к высшему):

1.  **Dockerfile `ENV`**: Значения по умолчанию, зашитые в образ.
    ```dockerfile
    ENV PORT=3000
    ```
2.  **Docker Compose `.env` файл**: Подстановка переменных в `docker-compose.yml`.
3.  **Docker CLI `-e`**: Явная передача при запуске (перекрывает всё).
    ```bash
    docker run -e PORT=8080 my-app
    ```

**Важно**: Переменные `ARG`, заданные в Dockerfile, доступны **только** во время сборки (`docker build`). В запущенном контейнере их нет, если вы явно не переложили их в `ENV`.

## Конфигурационные файлы (Configs)

Не всё удобно хранить в ENV (например, сложный `nginx.conf` или `prometheus.yml`).
Для этого используется паттерн **Injecting Configs via Volume**.

Вы не запекаете конфиг в образ, а подкладываете его в момент запуска через Bind Mount или Config object (в Swarm/K8s).

```yaml
# docker-compose.yml
services:
  nginx:
    image: nginx
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf:ro
```
Флаг `:ro` (Read-Only) гарантирует, что Nginx случайно не перезапишет свой конфиг.

## Динамическая генерация (Entrypoint scripts)

Частая проблема: Nginx не умеет читать переменные окружения в своём конфиге.
Решение: использовать скрипт-обертку на старте контейнера.

Паттерн **`envsubst`**:
1.  Создаем шаблон `nginx.conf.template` с переменными `$BACKEND_HOST`.
2.  При старте контейнера выполняем команду, которая заменяет переменные на реальные значения из ENV и сохраняет результат в рабочий конфиг.

```bash
#!/bin/sh
# entrypoint.sh
envsubst < /etc/nginx/nginx.conf.template > /etc/nginx/nginx.conf
exec nginx -g 'daemon off;'
```

## Управление Секретами (Secrets)

**Проблема ENV**: Если вы передаете пароль как `-e DB_PASSWORD=123`, любой, кто имеет доступ к серверу и выполнит `docker inspect container_id`, увидит пароль в открытом виде. Также он попадет в логи CI/CD.

**Решение (Docker Secrets)**:
Механизм, который монтирует секреты как файлы в оперативную память (`/run/secrets/my_pass`).
*   Приложение должно уметь читать пароль из файла, а не только из ENV.
*   Многие официальные образы (Postgres, MySQL) поддерживают суффикс `_FILE`.
    *   `POSTGRES_PASSWORD_FILE=/run/secrets/db_pass` — база прочитает пароль из файла.

Это наиболее безопасный способ работы с чувствительными данными в контейнерной среде.
