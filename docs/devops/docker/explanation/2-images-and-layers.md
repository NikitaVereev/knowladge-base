---
title: "2 Образы и слои"
description: "Глубокое понимание UnionFS, Copy-on-Write и стратегии кэширования для создания легких и быстрых образов."
---

В основе Docker лежит **Union File System (UnionFS)** — технология, позволяющая объединять содержимое нескольких директорий (слоев) в единую виртуальную файловую систему. Понимание этого механизма — ключ к созданию компактных образов и быстрой сборке.

## Анатомия Образа

Образ (Image) — это неизменяемый (read-only) шаблон. Он состоит из стека слоев, каждый из которых представляет собой разницу (diff) файловой системы по сравнению с предыдущим слоем.

### Как формируются слои
Почти каждая инструкция в `Dockerfile` создает новый слой.
> **Нюанс:** Начиная с современных версий Docker (BuildKit), только инструкции `RUN`, `COPY`, и `ADD` создают слои, которые увеличивают размер образа. Метаданные (`ENV`, `EXPOSE`, `CMD`) создают временные промежуточные слои нулевого размера.

Пример `Dockerfile` и его слои:
1.  `FROM ubuntu:24.04` — Базовый слой ОС (около 70MB).
2.  `RUN apt update && apt install python3` — Слой с файлами Python (добавляет ~50MB).
3.  `COPY app.py .` — Слой с вашим кодом (добавляет 5KB).

Docker объединяет эти слои так, что вы видите единую файловую систему, где `python3` и `app.py` находятся "вместе".

## Механизм Copy-on-Write (CoW)

Когда вы запускаете контейнер, Docker не копирует весь гигабайтный образ. Вместо этого он добавляет **тонкий слой для записи (Read-Write Layer)** поверх стека read-only слоев образа.

*   **Чтение:** Если процесс хочет прочитать файл `/etc/nginx.conf`, Docker ищет его сверху вниз по слоям. Находит в образе — отдает процесс.
*   **Запись (CoW):** Если процесс хочет **изменить** `/etc/nginx.conf`:
    1.  Docker ищет файл в read-only слое.
    2.  Копирует файл в верхний read-write слой контейнера (это и есть "Copy").
    3.  Процесс меняет копию в read-write слое ("Write").

**Проблема "удаленных" файлов:**
Если вы выполните `RUN rm /big-file` в новом слое, файл **не удалится физически** из образа. Он просто помечается как "whiteout" (скрытый) в новом слое.
*   *Результат:* Файл недоступен в контейнере, но образ по-прежнему занимает место, так как файл остался в предыдущем слое.
*   *Решение:* Удаляйте файлы в **том же** слое `RUN`, где они были созданы.
    ```dockerfile
    # Плохо (создает 2 слоя, мусор остается)
    RUN wget https://example.com/big-archive.zip
    RUN unzip big-archive.zip && rm big-archive.zip

    # Хорошо (все происходит в одном слое)
    RUN wget https://example.com/big-archive.zip && \
        unzip big-archive.zip && \
        rm big-archive.zip
    ```

## Кэширование сборки (Build Cache)

Docker ускоряет сборку, переиспользуя уже собранные слои, если входные данные не изменились.

**Логика инвалидации кэша:**
1.  Docker проверяет инструкцию и ее родительский слой.
2.  Для `ADD` и `COPY` он считает контрольную сумму (checksum) содержимого файлов.
3.  Для `RUN` он просто сравнивает текст команды.

Если на шаге N кэш "протух" (изменился файл или команда), то **все последующие шаги (N+1, N+2...) пересобираются заново**.

### Best Practice: Оптимизация порядка слоев

Располагайте инструкции от **наименее** часто изменяемых к **наиболее** часто изменяемым.

**Плохой пример:**
```dockerfile
COPY . .                  # Код меняется при каждом коммите -> Кэш сбрасывается
RUN npm install           # Эта тяжелая операция будет выполняться КАЖДЫЙ РАЗ заново
```

**Хороший пример:**
```dockerfile
COPY package.json .       # Меняется редко (только при добавлении библиотек)
RUN npm install           # Берется из кэша, если package.json не менялся
COPY . .                  # Меняется часто, но тяжелая работа уже сделана/закэширована
```

## Уменьшение размера (Multi-stage Builds)

Самый современный способ создания минимальных образов. Вы используете один образ для сборки (где есть компиляторы, исходники, хедеры), а другой — только для запуска (только бинарник).

```dockerfile
# Stage 1: Build
FROM golang:1.21 AS builder
WORKDIR /app
COPY . .
RUN go build -o myapp main.go

# Stage 2: Runtime
FROM alpine:latest
WORKDIR /root/
# Копируем ТОЛЬКО скомпилированный файл из предыдущего этапа
COPY --from=builder /app/myapp .
CMD ["./myapp"]
```
*Результат:* Образ весит 10MB (Alpine + Binary) вместо 800MB (Golang Image).
