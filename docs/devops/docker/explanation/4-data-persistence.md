---
title: 4 Хранение данных - Volumes и Bind Mounts
description: Как сохранить данные, когда контейнер умирает? Различия между Bind Mounts, Docker Volumes и tmpfs. Проблемы прав доступа (Permissions).
---

## Проблема: Эфемерность контейнера

По умолчанию все файлы, созданные внутри контейнера, живут в его **RW-слое** ([[devops/docker/explanation/3-image-construction|см. главу 3]]).
Когда вы удаляете контейнер (`docker rm`), этот слой уничтожается. Вместе с ним исчезают логи, базы данных и загруженные пользователем файлы.

Чтобы данные пережили пересоздание контейнера, их нужно вынести за пределы UnionFS — на хост-систему.

## Три типа монтирования

Docker предлагает три механизма для проброса данных. Выбор зависит от стадии разработки (Dev vs Prod).

### 1. Bind Mounts (Монтирование папок)
Прямое отображение папки с хоста в контейнер.
*   **Синтаксис**: `-v /home/user/project:/app`
*   **Суть**: Контейнер получает доступ к произвольной папке вашей ОС.
*   **Use Case**: **Локальная разработка**. Вы меняете код в IDE на хосте — изменения мгновенно появляются внутри контейнера (Hot Reload).
*   **Риски**: Контейнер может случайно удалить системные файлы хоста, если смонтировать `/`. Зависит от структуры файлов хоста (не переносимо).

### 2. Docker Volumes (Тома)
Управляемая Docker область хранения. Данные лежат где-то в недрах Docker (обычно `/var/lib/docker/volumes/...`), и вам не нужно знать, где именно.
*   **Синтаксис**: `-v my-db-data:/var/lib/postgresql/data`
*   **Суть**: Вы оперируете логическим именем тома (`my-db-data`).
*   **Use Case**: **Базы данных (Prod/Dev)**.
    *   *Производительность*: Volumes работают быстрее на Docker Desktop (Mac/Windows), так как не используют медленные трансляции файловых систем ОС.
    *   *Безопасность*: Другие процессы ОС не лезут в эти файлы.
    *   *Переносимость*: Конфиг не зависит от путей на конкретном сервере.

### 3. tmpfs (RAM Disk)
Данные хранятся только в оперативной памяти хоста. Ничего не пишется на диск.
*   **Use Case**: Хранение секретов (ключи шифрования), кеши, временные файлы, которые нужны для скорости, но не должны остаться на диске после перезагрузки.

## Проблема прав доступа (Permissions Hell)

Классическая проблема при использовании **Bind Mounts**:
1.  Контейнер (например, Node.js) работает от пользователя `node` (UID 1000).
2.  Вы монтируете папку с хоста, которая принадлежит `root` (UID 0).
3.  Приложение падает с ошибкой `EACCES: permission denied`, так как не может писать в папку.

**Docker Volumes** решают эту проблему автоматически: при создании тома Docker инициализирует его правами того пользователя, который указан в `Dockerfile`.

## Резюме: Что выбрать?

| Сценарий | Лучший выбор | Почему? |
| :--- | :--- | :--- |
| **Код приложения (Dev)** | **Bind Mount** | Чтобы работал Hot Reload при изменении кода. |
| **База данных** | **Volume** | Скорость, надежность, нет проблем с правами Linux. |
| **Конфиг файлы (nginx.conf)** | **Bind Mount** | Удобно править конфиг и делать `docker restart`. |
| **База данных (Backup)** | **Volume** + **Bind** | Подключаем Volume для работы БД, и временно Bind Mount для экспорта дампа `pg_dump > /backup/dump.sql`. |

**Best Practice**: В продакшене старайтесь использовать только Volumes (или драйверы облачных хранилищ), чтобы не привязываться к структуре папок конкретного сервера.
