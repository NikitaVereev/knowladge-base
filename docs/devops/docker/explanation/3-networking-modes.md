---
title: "3 Сетевые режимы"
description: "Разбор сетевых драйверов Docker (bridge, host, overlay, macvlan) и решение проблемы DNS через пользовательские сети."
---

Docker имеет подключаемую систему сетевых драйверов, которые определяют, как контейнеры общаются между собой и с внешним миром. Понимание этих режимов критично для настройки микросервисов.

## Основные драйверы (Drivers)

### 1. Bridge (Мост) — `bridge` (Default)
Это самый частый режим. Docker создает виртуальный коммутатор (bridge) `docker0`, к которому подключаются контейнеры.
*   **Изоляция:** Контейнер имеет свой приватный IP-адрес. Порты **закрыты** по умолчанию.
*   **Доступ снаружи:** Чтобы попасть в контейнер извне (например, с вашего ноутбука), нужно явно "пробросить" порт флагом `-p 8080:80` (NAT).
*   **Когда использовать:** В 95% случаев для обычных приложений (веб-серверы, БД), работающих на одном хосте.

### 2. Host — `host`
Убирает сетевую изоляцию между контейнером и хостом.
*   **Изоляция:** Отсутствует. Контейнер "садится" прямо на сетевой интерфейс вашего сервера.
*   **IP и Порты:** Если контейнер слушает порт 80, он займет порт 80 **прямо на хосте**. Флаг `-p` игнорируется.
*   **Плюс:** Максимальная производительность (нет накладных расходов на NAT) — полезно для VoIP, видеостриминга.
*   **Минус:** Возможны конфликты портов (нельзя запустить два одинаковых nginx). Не работает на macOS/Windows (Docker Desktop) из-за виртуализации.

### 3. None — `none`
Полное отсутствие сети. В контейнере есть только loopback (`lo`).
*   **Когда использовать:** Для задач с высокой безопасностью, где сети быть не должно вообще (например, генерация ключей, batch-обработка файлов).

### 4. Macvlan
Продвинутый режим, позволяющий контейнеру выглядеть как физическое устройство в вашей локальной сети.
*   **Как работает:** Контейнер получает собственный MAC-адрес и реальный IP из вашей локальной сети (например, 192.168.1.50), минуя NAT хоста.
*   **Когда использовать:** При миграции старых (legacy) приложений, которым нужен прямой доступ к L2-сети, или для мониторинга сетевого трафика.

## DNS и Service Discovery

Одна из главных болей новичков: "Почему мой код не видит базу данных по адресу `localhost`?".
Ответ: `localhost` внутри контейнера — это сам контейнер, а не ваш компьютер.

Контейнеры должны обращаться друг к другу по **именам**. Но есть нюанс.

### Проблема "Default Bridge"
Если вы запускаете контейнеры без указания сети (`docker run ...`), они попадают в дефолтную сеть `bridge`.
*   **Проблема:** В этой сети **НЕ работает** автоматический DNS. Вы не можете сделать `ping postgres`. Контейнеры видят друг друга только по IP, которые постоянно меняются.
*   **Решение:** Никогда не используйте дефолтную сеть для продакшена.

### Правильное решение: User-defined Bridge
Создайте свою сеть, и магия DNS заработает.

```bash
# 1. Создаем сеть
docker network create my-app-net

# 2. Запускаем базу с именем 'db'
docker run -d --name db --network my-app-net postgres

# 3. Запускаем приложение
docker run -d --network my-app-net my-web-app
```

Теперь внутри `my-web-app` вы можете обращаться к базе просто по имени хоста: `db`. Docker содержит встроенный DNS-сервер (по адресу `127.0.0.11`), который автоматически резолвит имя контейнера в его актуальный IP.

> **Best Practice:** В `docker-compose.yaml` кастомная сеть создается автоматически, поэтому там обращение по именам сервисов (service name) работает из коробки.
