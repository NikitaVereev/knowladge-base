---
title: "2 Справочник Dockerfile"
description: "Детальный разбор инструкций: разница между COPY/ADD и CMD/ENTRYPOINT, мультистейдж сборки и best practices 2026."
---

Dockerfile — это рецепт для сборки образа. Инструкции выполняются сверху вниз, и каждая (почти каждая) создает новый слой.

## 1. Базовые инструкции

### `FROM`
Задает базовый образ. Должна быть первой инструкцией (кроме `ARG`).
```dockerfile
# Использование конкретной версии — best practice
FROM node:20-alpine
# Мультистейдж сборка (Alias 'builder')
FROM python:3.11-slim AS builder
```

### `WORKDIR`
Устанавливает рабочую директорию для всех последующих команд (`RUN`, `CMD`, `COPY`).
*   Если папки нет, она создается.
*   **Best Practice:** Используйте абсолютные пути.
```dockerfile
WORKDIR /app
```

### `COPY` vs `ADD`
Копирование файлов внутрь образа.
*   **`COPY . .`**: Просто копирует файлы с хоста. **Используйте в 99% случаев.**
*   **`ADD url dest`**: Умеет качать файлы по URL и **автоматически распаковывать** архивы (`.tar.gz`).
    > *Почему `ADD` опасен:* Он может распаковать zip-бомбу или скачать файл с уязвимостью. Используйте `RUN curl/wget` для скачивания, чтобы контролировать процесс.

### `RUN`
Выполняет команду **во время сборки** образа и создает новый слой с результатом.
*   Используется для установки пакетов, сборки кода.
*   **Best Practice:** Объединяйте команды в одну цепочку `&&`, чтобы уменьшить количество слоев.
```dockerfile
RUN apt-get update && \
    apt-get install -y curl && \
    rm -rf /var/lib/apt/lists/*
# Очистка кэша apt в том же слое экономит место!
```

## 2. Инструкции запуска

### `CMD` vs `ENTRYPOINT`
Определяют, что запустится при старте контейнера.

| Инструкция | Переопределяемость | Назначение |
| :--- | :--- | :--- |
| **`CMD`** | Легко заменить при `docker run` | Команда по умолчанию. |
| **`ENTRYPOINT`** | Сложно (флаг `--entrypoint`) | Главный исполняемый процесс. |

#### Сценарий 1: Просто приложение (CMD)
```dockerfile
CMD ["node", "app.js"]
```
*   `docker run my-app`: Выполнит `node app.js`.
*   `docker run my-app echo hi`: Выполнит `echo hi` (заменит CMD).

#### Сценарий 2: Утилита с аргументами (ENTRYPOINT + CMD)
```dockerfile
ENTRYPOINT ["ping"]
CMD ["google.com"]
```
*   `docker run my-app`: Выполнит `ping google.com` (ENTRYPOINT + CMD).
*   `docker run my-app 8.8.8.8`: Выполнит `ping 8.8.8.8` (ENTRYPOINT + аргумент пользователя).

## 3. Переменные

### `ENV` vs `ARG`
*   **`ARG`**: Доступна **только во время сборки** (`docker build`).
    ```dockerfile
    ARG VERSION=1.0
    RUN echo "Building version $VERSION"
    ```
*   **`ENV`**: Доступна **и при сборке, и внутри запущенного контейнера** (`docker run`).
    ```dockerfile
    ENV PORT=8080
    CMD ["node", "server.js"] # server.js может прочитать process.env.PORT
    ```

## 4. Метаданные

### `EXPOSE`
```dockerfile
EXPOSE 80/tcp
```
Это **просто документация** для человека/инструментов. Она сообщает, что приложение *слушает* порт 80. Но **не открывает** его наружу (для этого нужен `-p 80:80` при запуске).

### `VOLUME`
```dockerfile
VOLUME ["/data"]
```
Создает анонимный том при запуске.
> *Осторожно:* Если вы объявили папку как `VOLUME`, последующие команды `RUN` не смогут ничего изменить в этой папке (изменения сбросятся). Объявляйте `VOLUME` в самом конце.
